using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace UnityMVVM.Base
{
  /// <summary>
  /// A common base that defines the standard interfacing and functionality for all Unity data-templates.
  /// </summary>
  /// <remarks>
  /// <para>A <see cref="Template" /> is a <see cref="Binding" /> that defines a relationship between a model (e.g. <see cref="Binding.IViewModel" />) and a view (e.g. <see cref="GameObject" />).</para>
  /// <para>One or multiple <see cref="GameObject" />s are generated when bound to either an <see cref="object" /> or a <see cref="Binding.IViewList" /> respectively.</para>
  /// <para>Asynchronous designs will put the responsibility of latent user experience on the prefab rather than the <see cref="Binding" />.</para>
  /// </remarks>
  /// <example>
  ///  <code>
  ///  public class MyTemplate : Template
  ///  {
  ///   protected override GameObject Instantiate(object model, GameObject recycled = default) {
  ///    // Instantiate a prefab
  ///   }  
  ///  }
  ///  </code>  
  /// </example>
  public abstract partial class Template : Binding, IEnumerable<Template.Instance>
  {
    private Instance[] _views = new Instance[0];
    /// <summary>
    /// Sets the <see cref="Transform" /> parent the <see cref="Template" /> <see cref="Instance" />s will be added to.
    /// </summary>
    [SerializeField] public Transform TransformParent;
    /// <summary>
    /// Sets the positioning strategy for the prefab instances generated by this template.
    /// </summary>
    [SerializeField] public LayoutStrategy Layout;
    /// <summary>
    /// When overridden, resolves the prefab instance for the model instance that will be added to the scene.
    /// </summary>
    /// <param name="model">The model instance</param>
    /// <param name="recycled">The previous prefab instance, if any, used for the current index</param>
    /// <returns>The prefab instance</returns>
    /// <example>
    ///  <code>
    ///  public class MyTemplate : Template
    ///  {
    ///   protected override GameObject Instantiate(object model, GameObject recycled = default) {
    ///    // Instantiate a prefab
    ///   }  
    ///  }
    ///  </code>  
    /// </example>
    protected abstract GameObject Instantiate(object model, GameObject recycled = default);
    /// <inheritdoc />
    public override void Bind(object model)
    {
      var values = model is IViewList set ? set : model == null ? Enumerable.Empty<object>() : Yield(model);
      var dirty = _views;
      _views = values
        .Select((value, index) => {
          var prefab = Instantiate(value, _views.ElementAtOrDefault(index)?.gameObject);
          if (prefab == null) { prefab = new GameObject(model?.GetType().Name ?? "Template Placeholder"); }
          prefab.transform.SetParent(TransformParent != null ? TransformParent : transform);
          var view = prefab.GetComponent<Instance>() ?? prefab.AddComponent<Instance>();
          view.Bind(view.TemplateBinding = value);
          return view;
        })
        .ToArray();
      foreach (var discard in dirty.Except(_views)) { Destroy(discard.gameObject); }
      (Layout ?? LayoutStrategy.Default)
        .Arrange(model, _views.AsEnumerable());
    }
    /// <inheritdoc />
    public IEnumerator<Instance> GetEnumerator() => _views.AsEnumerable().GetEnumerator();
    /// <inheritdoc />
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
  }
}