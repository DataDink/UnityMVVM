using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace UnityMVVM.Base
{
  /// <summary>
  /// A common base that defines the standard interfacing and functionality for all Unity data-templates.
  /// </summary>
  /// <remarks>
  /// <para>A <see cref="Template" /> is a <see cref="Binding" /> that defines a relationship between a model (e.g. <see cref="Binding.IModel" />) and a view (e.g. <see cref="GameObject" />).</para>
  /// <para>One or multiple <see cref="GameObject" />s are generated when bound to either an <see cref="object" /> or a <see cref="Binding.ISet" /> respectively.</para>
  /// <para>Asynchronous designs will put the responsibility of latent user experience on the prefab rather than the <see cref="Binding" />.</para>
  /// </remarks>
  public abstract class Template : Binding, IEnumerable<View>
  {
    private readonly List<TemplateView> _views = new();
    /// <summary>
    /// When overridden, resolves the prefab instance for the model instance that will be added to the scene.
    /// </summary>
    /// <param name="model">The model instance</param>
    /// <param name="recycled">The previous prefab instance, if any, used for the current index</param>
    /// <returns>The new or recycled prefab as applicable</returns>
    protected abstract GameObject Instantiate(object model, GameObject recycled = default);
    /// <summary>
    /// Clears all content generated by this template from the scene.
    /// </summary>
    public void Clear() { 
      foreach (var child in _views) { Destroy(child.gameObject); } 
      _views.Clear(); 
    }
    /// <summary>
    /// Removes an instance of content of this template from the scene.
    /// </summary>
    public void Remove(View instance) { 
      if (instance is TemplateView view && _views.Contains(view)) { 
        Destroy(instance.gameObject); 
        _views.Remove(view); 
      } 
    }
    /// <inheritdoc cref="Remove(View)" />
    public void Remove(GameObject instance) => Remove(_views.FirstOrDefault(view => view.gameObject == instance));
    /// <inheritdoc cref="Remove(View)" />
    public void Remove(int index) => Remove(_views.ElementAtOrDefault(index));
    /// <inheritdoc />
    public override void Bind(object model)
    {
      if (model == null) { Clear(); return; }
      var values = model is ISet set ? set.ToArray() : new[] { model };
      for (var i = 0; i < values.Length; i++) {
        var value = values[i];
        var existing = _views.ElementAtOrDefault(i);
        var prefab = Instantiate(value, _views.ElementAtOrDefault(i)?.gameObject) ?? new GameObject(model?.GetType().Name ?? "Null Template");
        prefab.transform.SetParent(transform);
        if (existing != null && prefab != existing.gameObject) { Destroy(existing.gameObject); }
        var view = prefab.GetComponent<TemplateView>() ?? prefab.AddComponent<TemplateView>();
        if (i < _views.Count) { _views[i] = view; } else { _views.Add(view); }
        view.Bind(value);
      }
      if (_views.Count > values.Length) {
        var trash = _views.GetRange(values.Length, _views.Count - values.Length);
        _views.RemoveRange(values.Length, trash.Count);
        trash.ForEach(t => Destroy(t.gameObject));
      }
    }
    /// <inheritdoc />
    public IEnumerator<View> GetEnumerator() => _views.GetEnumerator();
    /// <inheritdoc />
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    /// <summary>
    /// A specialized <see cref="View" /> added to the prefab instances generated by the <see cref="Template" />.
    /// </summary>
    protected class TemplateView : View 
    {
      protected object _instance;
      /// <inheritdoc />
      protected override object Select(object model) => _instance;
      /// <inheritdoc />
      public override void Bind(object model) => base.Bind(_instance = model);
    }
  }
}